{"version":3,"file":"static/js/459.1ed98af1.chunk.js","mappings":"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","sources":["../node_modules/mdast-util-math/lib/index.js","../node_modules/longest-streak/index.js","../node_modules/micromark-extension-math/lib/math-flow.js","../node_modules/micromark-extension-math/lib/math-text.js","../node_modules/remark-math/lib/index.js","../node_modules/micromark-extension-math/lib/syntax.js"],"sourcesContent":["/**\n * @typedef {import('hast').Element} HastElement\n * @typedef {import('hast').ElementContent} HastElementContent\n * @typedef {import('mdast-util-from-markdown').CompileContext} CompileContext\n * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension\n * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle\n * @typedef {import('mdast-util-to-markdown').Handle} ToMarkdownHandle\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension\n * @typedef {import('../index.js').InlineMath} InlineMath\n * @typedef {import('../index.js').Math} Math\n *\n * @typedef ToOptions\n *   Configuration.\n * @property {boolean | null | undefined} [singleDollarTextMath=true]\n *   Whether to support math (text) with a single dollar (default: `true`).\n *\n *   Single dollars work in Pandoc and many other places, but often interfere\n *   with “normal” dollars in text.\n *   If you turn this off, you can still use two or more dollars for text math.\n */\n\nimport {ok as assert} from 'devlop'\nimport {longestStreak} from 'longest-streak'\n\n/**\n * Create an extension for `mdast-util-from-markdown`.\n *\n * @returns {FromMarkdownExtension}\n *   Extension for `mdast-util-from-markdown`.\n */\nexport function mathFromMarkdown() {\n  return {\n    enter: {\n      mathFlow: enterMathFlow,\n      mathFlowFenceMeta: enterMathFlowMeta,\n      mathText: enterMathText\n    },\n    exit: {\n      mathFlow: exitMathFlow,\n      mathFlowFence: exitMathFlowFence,\n      mathFlowFenceMeta: exitMathFlowMeta,\n      mathFlowValue: exitMathData,\n      mathText: exitMathText,\n      mathTextData: exitMathData\n    }\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function enterMathFlow(token) {\n    /** @type {HastElement} */\n    const code = {\n      type: 'element',\n      tagName: 'code',\n      properties: {className: ['language-math', 'math-display']},\n      children: []\n    }\n    this.enter(\n      {\n        type: 'math',\n        meta: null,\n        value: '',\n        data: {hName: 'pre', hChildren: [code]}\n      },\n      token\n    )\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function enterMathFlowMeta() {\n    this.buffer()\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function exitMathFlowMeta() {\n    const data = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    assert(node.type === 'math')\n    node.meta = data\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function exitMathFlowFence() {\n    // Exit if this is the closing fence.\n    if (this.data.mathFlowInside) return\n    this.buffer()\n    this.data.mathFlowInside = true\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function exitMathFlow(token) {\n    const data = this.resume().replace(/^(\\r?\\n|\\r)|(\\r?\\n|\\r)$/g, '')\n    const node = this.stack[this.stack.length - 1]\n    assert(node.type === 'math')\n    this.exit(token)\n    node.value = data\n    // @ts-expect-error: we defined it in `enterMathFlow`.\n    const code = /** @type {HastElement} */ (node.data.hChildren[0])\n    assert(code.type === 'element')\n    assert(code.tagName === 'code')\n    code.children.push({type: 'text', value: data})\n    this.data.mathFlowInside = undefined\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function enterMathText(token) {\n    this.enter(\n      {\n        type: 'inlineMath',\n        value: '',\n        data: {\n          hName: 'code',\n          hProperties: {className: ['language-math', 'math-inline']},\n          hChildren: []\n        }\n      },\n      token\n    )\n    this.buffer()\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function exitMathText(token) {\n    const data = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    assert(node.type === 'inlineMath')\n    this.exit(token)\n    node.value = data\n    const children = /** @type {Array<HastElementContent>} */ (\n      // @ts-expect-error: we defined it in `enterMathFlow`.\n      node.data.hChildren\n    )\n    children.push({type: 'text', value: data})\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function exitMathData(token) {\n    this.config.enter.data.call(this, token)\n    this.config.exit.data.call(this, token)\n  }\n}\n\n/**\n * Create an extension for `mdast-util-to-markdown`.\n *\n * @param {ToOptions | null | undefined} [options]\n *   Configuration (optional).\n * @returns {ToMarkdownExtension}\n *   Extension for `mdast-util-to-markdown`.\n */\nexport function mathToMarkdown(options) {\n  let single = (options || {}).singleDollarTextMath\n\n  if (single === null || single === undefined) {\n    single = true\n  }\n\n  inlineMath.peek = inlineMathPeek\n\n  return {\n    unsafe: [\n      {character: '\\r', inConstruct: 'mathFlowMeta'},\n      {character: '\\n', inConstruct: 'mathFlowMeta'},\n      {\n        character: '$',\n        after: single ? undefined : '\\\\$',\n        inConstruct: 'phrasing'\n      },\n      {character: '$', inConstruct: 'mathFlowMeta'},\n      {atBreak: true, character: '$', after: '\\\\$'}\n    ],\n    handlers: {math, inlineMath}\n  }\n\n  /**\n   * @type {ToMarkdownHandle}\n   * @param {Math} node\n   */\n  // Note: fixing this code? Please also fix the similar code for code:\n  // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/main/lib/handle/code.js>\n  function math(node, _, state, info) {\n    const raw = node.value || ''\n    const tracker = state.createTracker(info)\n    const sequence = '$'.repeat(Math.max(longestStreak(raw, '$') + 1, 2))\n    const exit = state.enter('mathFlow')\n    let value = tracker.move(sequence)\n\n    if (node.meta) {\n      const subexit = state.enter('mathFlowMeta')\n      value += tracker.move(\n        state.safe(node.meta, {\n          after: '\\n',\n          before: value,\n          encode: ['$'],\n          ...tracker.current()\n        })\n      )\n      subexit()\n    }\n\n    value += tracker.move('\\n')\n\n    if (raw) {\n      value += tracker.move(raw + '\\n')\n    }\n\n    value += tracker.move(sequence)\n    exit()\n    return value\n  }\n\n  /**\n   * @type {ToMarkdownHandle}\n   * @param {InlineMath} node\n   */\n  // Note: fixing this code? Please also fix the similar code for inline code:\n  // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/main/lib/handle/inline-code.js>\n  function inlineMath(node, _, state) {\n    let value = node.value || ''\n    let size = 1\n\n    if (!single) size++\n\n    // If there is a single dollar sign on its own in the math, use a fence of\n    // two.\n    // If there are two in a row, use one.\n    while (\n      new RegExp('(^|[^$])' + '\\\\$'.repeat(size) + '([^$]|$)').test(value)\n    ) {\n      size++\n    }\n\n    const sequence = '$'.repeat(size)\n\n    // If this is not just spaces or eols (tabs don’t count), and either the\n    // first and last character are a space or eol, or the first or last\n    // character are dollar signs, then pad with spaces.\n    if (\n      // Contains non-space.\n      /[^ \\r\\n]/.test(value) &&\n      // Starts with space and ends with space.\n      ((/^[ \\r\\n]/.test(value) && /[ \\r\\n]$/.test(value)) ||\n        // Starts or ends with dollar.\n        /^\\$|\\$$/.test(value))\n    ) {\n      value = ' ' + value + ' '\n    }\n\n    let index = -1\n\n    // We have a potential problem: certain characters after eols could result in\n    // blocks being seen.\n    // For example, if someone injected the string `'\\n# b'`, then that would\n    // result in an ATX heading.\n    // We can’t escape characters in `inlineMath`, but because eols are\n    // transformed to spaces when going from markdown to HTML anyway, we can swap\n    // them out.\n    while (++index < state.unsafe.length) {\n      const pattern = state.unsafe[index]\n\n      // Only look for `atBreak`s.\n      // Btw: note that `atBreak` patterns will always start the regex at LF or\n      // CR.\n      if (!pattern.atBreak) continue\n\n      const expression = state.compilePattern(pattern)\n      /** @type {RegExpExecArray | null} */\n      let match\n\n      while ((match = expression.exec(value))) {\n        let position = match.index\n\n        // Support CRLF (patterns only look for one of the characters).\n        if (\n          value.codePointAt(position) === 10 /* `\\n` */ &&\n          value.codePointAt(position - 1) === 13 /* `\\r` */\n        ) {\n          position--\n        }\n\n        value = value.slice(0, position) + ' ' + value.slice(match.index + 1)\n      }\n    }\n\n    return sequence + value + sequence\n  }\n\n  /**\n   * @returns {string}\n   */\n  function inlineMathPeek() {\n    return '$'\n  }\n}\n","/**\n * Get the count of the longest repeating streak of `substring` in `value`.\n *\n * @param {string} value\n *   Content to search in.\n * @param {string} substring\n *   Substring to look for, typically one character.\n * @returns {number}\n *   Count of most frequent adjacent `substring`s in `value`.\n */\nexport function longestStreak(value, substring) {\n  const source = String(value)\n  let index = source.indexOf(substring)\n  let expected = index\n  let count = 0\n  let max = 0\n\n  if (typeof substring !== 'string') {\n    throw new TypeError('Expected substring')\n  }\n\n  while (index !== -1) {\n    if (index === expected) {\n      if (++count > max) {\n        max = count\n      }\n    } else {\n      count = 1\n    }\n\n    expected = index + substring.length\n    index = source.indexOf(substring, expected)\n  }\n\n  return max\n}\n","/**\n * @import {Construct, State, TokenizeContext, Tokenizer} from 'micromark-util-types'\n */\n\nimport { factorySpace } from 'micromark-factory-space';\nimport { markdownLineEnding } from 'micromark-util-character';\n/** @type {Construct} */\nexport const mathFlow = {\n  tokenize: tokenizeMathFenced,\n  concrete: true,\n  name: 'mathFlow'\n};\n\n/** @type {Construct} */\nconst nonLazyContinuation = {\n  tokenize: tokenizeNonLazyContinuation,\n  partial: true\n};\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeMathFenced(effects, ok, nok) {\n  const self = this;\n  const tail = self.events[self.events.length - 1];\n  const initialSize = tail && tail[1].type === \"linePrefix\" ? tail[2].sliceSerialize(tail[1], true).length : 0;\n  let sizeOpen = 0;\n  return start;\n\n  /**\n   * Start of math.\n   *\n   * ```markdown\n   * > | $$\n   *     ^\n   *   | \\frac{1}{2}\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    effects.enter('mathFlow');\n    effects.enter('mathFlowFence');\n    effects.enter('mathFlowFenceSequence');\n    return sequenceOpen(code);\n  }\n\n  /**\n   * In opening fence sequence.\n   *\n   * ```markdown\n   * > | $$\n   *      ^\n   *   | \\frac{1}{2}\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n  function sequenceOpen(code) {\n    if (code === 36) {\n      effects.consume(code);\n      sizeOpen++;\n      return sequenceOpen;\n    }\n    if (sizeOpen < 2) {\n      return nok(code);\n    }\n    effects.exit('mathFlowFenceSequence');\n    return factorySpace(effects, metaBefore, \"whitespace\")(code);\n  }\n\n  /**\n   * In opening fence, before meta.\n   *\n   * ```markdown\n   * > | $$asciimath\n   *       ^\n   *   | x < y\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n\n  function metaBefore(code) {\n    if (code === null || markdownLineEnding(code)) {\n      return metaAfter(code);\n    }\n    effects.enter('mathFlowFenceMeta');\n    effects.enter(\"chunkString\", {\n      contentType: \"string\"\n    });\n    return meta(code);\n  }\n\n  /**\n   * In meta.\n   *\n   * ```markdown\n   * > | $$asciimath\n   *        ^\n   *   | x < y\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n  function meta(code) {\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit(\"chunkString\");\n      effects.exit('mathFlowFenceMeta');\n      return metaAfter(code);\n    }\n    if (code === 36) {\n      return nok(code);\n    }\n    effects.consume(code);\n    return meta;\n  }\n\n  /**\n   * After meta.\n   *\n   * ```markdown\n   * > | $$\n   *       ^\n   *   | \\frac{1}{2}\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n  function metaAfter(code) {\n    // Guaranteed to be eol/eof.\n    effects.exit('mathFlowFence');\n    if (self.interrupt) {\n      return ok(code);\n    }\n    return effects.attempt(nonLazyContinuation, beforeNonLazyContinuation, after)(code);\n  }\n\n  /**\n   * After eol/eof in math, at a non-lazy closing fence or content.\n   *\n   * ```markdown\n   *   | $$\n   * > | \\frac{1}{2}\n   *     ^\n   * > | $$\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function beforeNonLazyContinuation(code) {\n    return effects.attempt({\n      tokenize: tokenizeClosingFence,\n      partial: true\n    }, after, contentStart)(code);\n  }\n\n  /**\n   * Before math content, definitely not before a closing fence.\n   *\n   * ```markdown\n   *   | $$\n   * > | \\frac{1}{2}\n   *     ^\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n  function contentStart(code) {\n    return (initialSize ? factorySpace(effects, beforeContentChunk, \"linePrefix\", initialSize + 1) : beforeContentChunk)(code);\n  }\n\n  /**\n   * Before math content, after optional prefix.\n   *\n   * ```markdown\n   *   | $$\n   * > | \\frac{1}{2}\n   *     ^\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n  function beforeContentChunk(code) {\n    if (code === null) {\n      return after(code);\n    }\n    if (markdownLineEnding(code)) {\n      return effects.attempt(nonLazyContinuation, beforeNonLazyContinuation, after)(code);\n    }\n    effects.enter('mathFlowValue');\n    return contentChunk(code);\n  }\n\n  /**\n   * In math content.\n   *\n   * ```markdown\n   *   | $$\n   * > | \\frac{1}{2}\n   *      ^\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n  function contentChunk(code) {\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit('mathFlowValue');\n      return beforeContentChunk(code);\n    }\n    effects.consume(code);\n    return contentChunk;\n  }\n\n  /**\n   * After math (ha!).\n   *\n   * ```markdown\n   *   | $$\n   *   | \\frac{1}{2}\n   * > | $$\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function after(code) {\n    effects.exit('mathFlow');\n    return ok(code);\n  }\n\n  /** @type {Tokenizer} */\n  function tokenizeClosingFence(effects, ok, nok) {\n    let size = 0;\n    /**\n     * Before closing fence, at optional whitespace.\n     *\n     * ```markdown\n     *   | $$\n     *   | \\frac{1}{2}\n     * > | $$\n     *     ^\n     * ```\n     */\n    return factorySpace(effects, beforeSequenceClose, \"linePrefix\", self.parser.constructs.disable.null.includes('codeIndented') ? undefined : 4);\n\n    /**\n     * In closing fence, after optional whitespace, at sequence.\n     *\n     * ```markdown\n     *   | $$\n     *   | \\frac{1}{2}\n     * > | $$\n     *     ^\n     * ```\n     *\n     * @type {State}\n     */\n    function beforeSequenceClose(code) {\n      effects.enter('mathFlowFence');\n      effects.enter('mathFlowFenceSequence');\n      return sequenceClose(code);\n    }\n\n    /**\n     * In closing fence sequence.\n     *\n     * ```markdown\n     *   | $$\n     *   | \\frac{1}{2}\n     * > | $$\n     *      ^\n     * ```\n     *\n     * @type {State}\n     */\n    function sequenceClose(code) {\n      if (code === 36) {\n        size++;\n        effects.consume(code);\n        return sequenceClose;\n      }\n      if (size < sizeOpen) {\n        return nok(code);\n      }\n      effects.exit('mathFlowFenceSequence');\n      return factorySpace(effects, afterSequenceClose, \"whitespace\")(code);\n    }\n\n    /**\n     * After closing fence sequence, after optional whitespace.\n     *\n     * ```markdown\n     *   | $$\n     *   | \\frac{1}{2}\n     * > | $$\n     *       ^\n     * ```\n     *\n     * @type {State}\n     */\n    function afterSequenceClose(code) {\n      if (code === null || markdownLineEnding(code)) {\n        effects.exit('mathFlowFence');\n        return ok(code);\n      }\n      return nok(code);\n    }\n  }\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeNonLazyContinuation(effects, ok, nok) {\n  const self = this;\n  return start;\n\n  /** @type {State} */\n  function start(code) {\n    if (code === null) {\n      return ok(code);\n    }\n    effects.enter(\"lineEnding\");\n    effects.consume(code);\n    effects.exit(\"lineEnding\");\n    return lineStart;\n  }\n\n  /** @type {State} */\n  function lineStart(code) {\n    return self.parser.lazy[self.now().line] ? nok(code) : ok(code);\n  }\n}","/**\n * @import {Options} from 'micromark-extension-math'\n * @import {Construct, Previous, Resolver, State, Token, TokenizeContext, Tokenizer} from 'micromark-util-types'\n */\n\n// To do: next major: clean spaces in HTML compiler.\n// This has to be coordinated together with `mdast-util-math`.\n\nimport { markdownLineEnding } from 'micromark-util-character';\n/**\n * @param {Options | null | undefined} [options={}]\n *   Configuration (default: `{}`).\n * @returns {Construct}\n *   Construct.\n */\nexport function mathText(options) {\n  const options_ = options || {};\n  let single = options_.singleDollarTextMath;\n  if (single === null || single === undefined) {\n    single = true;\n  }\n  return {\n    tokenize: tokenizeMathText,\n    resolve: resolveMathText,\n    previous,\n    name: 'mathText'\n  };\n\n  /**\n   * @this {TokenizeContext}\n   * @type {Tokenizer}\n   */\n  function tokenizeMathText(effects, ok, nok) {\n    const self = this;\n    let sizeOpen = 0;\n    /** @type {number} */\n    let size;\n    /** @type {Token} */\n    let token;\n    return start;\n\n    /**\n     * Start of math (text).\n     *\n     * ```markdown\n     * > | $a$\n     *     ^\n     * > | \\$a$\n     *      ^\n     * ```\n     *\n     * @type {State}\n     */\n    function start(code) {\n      effects.enter('mathText');\n      effects.enter('mathTextSequence');\n      return sequenceOpen(code);\n    }\n\n    /**\n     * In opening sequence.\n     *\n     * ```markdown\n     * > | $a$\n     *     ^\n     * ```\n     *\n     * @type {State}\n     */\n\n    function sequenceOpen(code) {\n      if (code === 36) {\n        effects.consume(code);\n        sizeOpen++;\n        return sequenceOpen;\n      }\n\n      // Not enough markers in the sequence.\n      if (sizeOpen < 2 && !single) {\n        return nok(code);\n      }\n      effects.exit('mathTextSequence');\n      return between(code);\n    }\n\n    /**\n     * Between something and something else.\n     *\n     * ```markdown\n     * > | $a$\n     *      ^^\n     * ```\n     *\n     * @type {State}\n     */\n    function between(code) {\n      if (code === null) {\n        return nok(code);\n      }\n      if (code === 36) {\n        token = effects.enter('mathTextSequence');\n        size = 0;\n        return sequenceClose(code);\n      }\n\n      // Tabs don’t work, and virtual spaces don’t make sense.\n      if (code === 32) {\n        effects.enter('space');\n        effects.consume(code);\n        effects.exit('space');\n        return between;\n      }\n      if (markdownLineEnding(code)) {\n        effects.enter(\"lineEnding\");\n        effects.consume(code);\n        effects.exit(\"lineEnding\");\n        return between;\n      }\n\n      // Data.\n      effects.enter('mathTextData');\n      return data(code);\n    }\n\n    /**\n     * In data.\n     *\n     * ```markdown\n     * > | $a$\n     *      ^\n     * ```\n     *\n     * @type {State}\n     */\n    function data(code) {\n      if (code === null || code === 32 || code === 36 || markdownLineEnding(code)) {\n        effects.exit('mathTextData');\n        return between(code);\n      }\n      effects.consume(code);\n      return data;\n    }\n\n    /**\n     * In closing sequence.\n     *\n     * ```markdown\n     * > | `a`\n     *       ^\n     * ```\n     *\n     * @type {State}\n     */\n\n    function sequenceClose(code) {\n      // More.\n      if (code === 36) {\n        effects.consume(code);\n        size++;\n        return sequenceClose;\n      }\n\n      // Done!\n      if (size === sizeOpen) {\n        effects.exit('mathTextSequence');\n        effects.exit('mathText');\n        return ok(code);\n      }\n\n      // More or less accents: mark as data.\n      token.type = 'mathTextData';\n      return data(code);\n    }\n  }\n}\n\n/** @type {Resolver} */\nfunction resolveMathText(events) {\n  let tailExitIndex = events.length - 4;\n  let headEnterIndex = 3;\n  /** @type {number} */\n  let index;\n  /** @type {number | undefined} */\n  let enter;\n\n  // If we start and end with an EOL or a space.\n  if ((events[headEnterIndex][1].type === \"lineEnding\" || events[headEnterIndex][1].type === 'space') && (events[tailExitIndex][1].type === \"lineEnding\" || events[tailExitIndex][1].type === 'space')) {\n    index = headEnterIndex;\n\n    // And we have data.\n    while (++index < tailExitIndex) {\n      if (events[index][1].type === 'mathTextData') {\n        // Then we have padding.\n        events[tailExitIndex][1].type = 'mathTextPadding';\n        events[headEnterIndex][1].type = 'mathTextPadding';\n        headEnterIndex += 2;\n        tailExitIndex -= 2;\n        break;\n      }\n    }\n  }\n\n  // Merge adjacent spaces and data.\n  index = headEnterIndex - 1;\n  tailExitIndex++;\n  while (++index <= tailExitIndex) {\n    if (enter === undefined) {\n      if (index !== tailExitIndex && events[index][1].type !== \"lineEnding\") {\n        enter = index;\n      }\n    } else if (index === tailExitIndex || events[index][1].type === \"lineEnding\") {\n      events[enter][1].type = 'mathTextData';\n      if (index !== enter + 2) {\n        events[enter][1].end = events[index - 1][1].end;\n        events.splice(enter + 2, index - enter - 2);\n        tailExitIndex -= index - enter - 2;\n        index = enter + 2;\n      }\n      enter = undefined;\n    }\n  }\n  return events;\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Previous}\n */\nfunction previous(code) {\n  // If there is a previous code, there will always be a tail.\n  return code !== 36 || this.events[this.events.length - 1][1].type === \"characterEscape\";\n}","/// <reference types=\"mdast-util-math\" />\n/// <reference types=\"remark-parse\" />\n/// <reference types=\"remark-stringify\" />\n\n/**\n * @typedef {import('mdast').Root} Root\n * @typedef {import('mdast-util-math').ToOptions} Options\n * @typedef {import('unified').Processor<Root>} Processor\n */\n\nimport {mathFromMarkdown, mathToMarkdown} from 'mdast-util-math'\nimport {math} from 'micromark-extension-math'\n\n/** @type {Readonly<Options>} */\nconst emptyOptions = {}\n\n/**\n * Add support for math.\n *\n * @param {Readonly<Options> | null | undefined} [options]\n *   Configuration (optional).\n * @returns {undefined}\n *   Nothing.\n */\nexport default function remarkMath(options) {\n  // @ts-expect-error: TS is wrong about `this`.\n  // eslint-disable-next-line unicorn/no-this-assignment\n  const self = /** @type {Processor} */ (this)\n  const settings = options || emptyOptions\n  const data = self.data()\n\n  const micromarkExtensions =\n    data.micromarkExtensions || (data.micromarkExtensions = [])\n  const fromMarkdownExtensions =\n    data.fromMarkdownExtensions || (data.fromMarkdownExtensions = [])\n  const toMarkdownExtensions =\n    data.toMarkdownExtensions || (data.toMarkdownExtensions = [])\n\n  micromarkExtensions.push(math(settings))\n  fromMarkdownExtensions.push(mathFromMarkdown())\n  toMarkdownExtensions.push(mathToMarkdown(settings))\n}\n","/**\n * @import {Options} from 'micromark-extension-math'\n * @import {Extension} from 'micromark-util-types'\n */\n\nimport { mathFlow } from './math-flow.js';\nimport { mathText } from './math-text.js';\n\n/**\n * Create an extension for `micromark` to enable math syntax.\n *\n * @param {Options | null | undefined} [options={}]\n *   Configuration (default: `{}`).\n * @returns {Extension}\n *   Extension for `micromark` that can be passed in `extensions`, to\n *   enable math syntax.\n */\nexport function math(options) {\n  return {\n    flow: {\n      [36]: mathFlow\n    },\n    text: {\n      [36]: mathText(options)\n    }\n  };\n}"],"names":["mathToMarkdown","options","single","singleDollarTextMath","undefined","inlineMath","peek","unsafe","character","inConstruct","after","atBreak","handlers","math","node","_","state","info","raw","value","tracker","createTracker","sequence","repeat","Math","max","substring","source","String","index","indexOf","expected","count","TypeError","length","longestStreak","exit","enter","move","meta","subexit","safe","_objectSpread","before","encode","current","size","RegExp","test","pattern","expression","compilePattern","match","exec","position","codePointAt","slice","mathFlow","tokenize","effects","ok","nok","self","this","tail","events","initialSize","type","sliceSerialize","sizeOpen","code","sequenceOpen","consume","factorySpace","metaBefore","markdownLineEnding","metaAfter","contentType","interrupt","attempt","nonLazyContinuation","beforeNonLazyContinuation","tokenizeClosingFence","partial","contentStart","beforeContentChunk","contentChunk","sequenceClose","parser","constructs","disable","null","includes","afterSequenceClose","concrete","name","lineStart","lazy","now","line","mathText","token","between","data","resolve","resolveMathText","previous","tailExitIndex","headEnterIndex","end","splice","emptyOptions","remarkMath","settings","micromarkExtensions","fromMarkdownExtensions","toMarkdownExtensions","push","flow","text","hName","hChildren","tagName","properties","className","children","mathFlowFenceMeta","buffer","hProperties","resume","replace","stack","assert","mathFlowInside","mathFlowFence","mathFlowValue","exitMathData","mathTextData","config","call","mathFromMarkdown"],"sourceRoot":""}