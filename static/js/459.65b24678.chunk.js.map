{"version":3,"file":"static/js/459.65b24678.chunk.js","mappings":"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","sources":["../node_modules/devlop/lib/default.js","../node_modules/micromark-util-character/index.js","../node_modules/mdast-util-math/lib/index.js","../node_modules/longest-streak/index.js","../node_modules/micromark-extension-math/lib/math-flow.js","../node_modules/micromark-extension-math/lib/math-text.js","../node_modules/remark-math/lib/index.js","../node_modules/micromark-extension-math/lib/syntax.js","../node_modules/micromark-factory-space/index.js"],"sourcesContent":["export function deprecate(fn) {\n  return fn\n}\n\nexport function equal() {}\n\nexport function ok() {}\n\nexport function unreachable() {}\n","/**\n * @import {Code} from 'micromark-util-types'\n */\n\n/**\n * Check whether the character code represents an ASCII alpha (`a` through `z`,\n * case insensitive).\n *\n * An **ASCII alpha** is an ASCII upper alpha or ASCII lower alpha.\n *\n * An **ASCII upper alpha** is a character in the inclusive range U+0041 (`A`)\n * to U+005A (`Z`).\n *\n * An **ASCII lower alpha** is a character in the inclusive range U+0061 (`a`)\n * to U+007A (`z`).\n *\n * @param code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport const asciiAlpha = regexCheck(/[A-Za-z]/);\n\n/**\n * Check whether the character code represents an ASCII alphanumeric (`a`\n * through `z`, case insensitive, or `0` through `9`).\n *\n * An **ASCII alphanumeric** is an ASCII digit (see `asciiDigit`) or ASCII alpha\n * (see `asciiAlpha`).\n *\n * @param code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport const asciiAlphanumeric = regexCheck(/[\\dA-Za-z]/);\n\n/**\n * Check whether the character code represents an ASCII atext.\n *\n * atext is an ASCII alphanumeric (see `asciiAlphanumeric`), or a character in\n * the inclusive ranges U+0023 NUMBER SIGN (`#`) to U+0027 APOSTROPHE (`'`),\n * U+002A ASTERISK (`*`), U+002B PLUS SIGN (`+`), U+002D DASH (`-`), U+002F\n * SLASH (`/`), U+003D EQUALS TO (`=`), U+003F QUESTION MARK (`?`), U+005E\n * CARET (`^`) to U+0060 GRAVE ACCENT (`` ` ``), or U+007B LEFT CURLY BRACE\n * (`{`) to U+007E TILDE (`~`).\n *\n * See:\n * **\\[RFC5322]**:\n * [Internet Message Format](https://tools.ietf.org/html/rfc5322).\n * P. Resnick.\n * IETF.\n *\n * @param code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport const asciiAtext = regexCheck(/[#-'*+\\--9=?A-Z^-~]/);\n\n/**\n * Check whether a character code is an ASCII control character.\n *\n * An **ASCII control** is a character in the inclusive range U+0000 NULL (NUL)\n * to U+001F (US), or U+007F (DEL).\n *\n * @param {Code} code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport function asciiControl(code) {\n  return (\n    // Special whitespace codes (which have negative values), C0 and Control\n    // character DEL\n    code !== null && (code < 32 || code === 127)\n  );\n}\n\n/**\n * Check whether the character code represents an ASCII digit (`0` through `9`).\n *\n * An **ASCII digit** is a character in the inclusive range U+0030 (`0`) to\n * U+0039 (`9`).\n *\n * @param code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport const asciiDigit = regexCheck(/\\d/);\n\n/**\n * Check whether the character code represents an ASCII hex digit (`a` through\n * `f`, case insensitive, or `0` through `9`).\n *\n * An **ASCII hex digit** is an ASCII digit (see `asciiDigit`), ASCII upper hex\n * digit, or an ASCII lower hex digit.\n *\n * An **ASCII upper hex digit** is a character in the inclusive range U+0041\n * (`A`) to U+0046 (`F`).\n *\n * An **ASCII lower hex digit** is a character in the inclusive range U+0061\n * (`a`) to U+0066 (`f`).\n *\n * @param code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport const asciiHexDigit = regexCheck(/[\\dA-Fa-f]/);\n\n/**\n * Check whether the character code represents ASCII punctuation.\n *\n * An **ASCII punctuation** is a character in the inclusive ranges U+0021\n * EXCLAMATION MARK (`!`) to U+002F SLASH (`/`), U+003A COLON (`:`) to U+0040 AT\n * SIGN (`@`), U+005B LEFT SQUARE BRACKET (`[`) to U+0060 GRAVE ACCENT\n * (`` ` ``), or U+007B LEFT CURLY BRACE (`{`) to U+007E TILDE (`~`).\n *\n * @param code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport const asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/);\n\n/**\n * Check whether a character code is a markdown line ending.\n *\n * A **markdown line ending** is the virtual characters M-0003 CARRIAGE RETURN\n * LINE FEED (CRLF), M-0004 LINE FEED (LF) and M-0005 CARRIAGE RETURN (CR).\n *\n * In micromark, the actual character U+000A LINE FEED (LF) and U+000D CARRIAGE\n * RETURN (CR) are replaced by these virtual characters depending on whether\n * they occurred together.\n *\n * @param {Code} code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport function markdownLineEnding(code) {\n  return code !== null && code < -2;\n}\n\n/**\n * Check whether a character code is a markdown line ending (see\n * `markdownLineEnding`) or markdown space (see `markdownSpace`).\n *\n * @param {Code} code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport function markdownLineEndingOrSpace(code) {\n  return code !== null && (code < 0 || code === 32);\n}\n\n/**\n * Check whether a character code is a markdown space.\n *\n * A **markdown space** is the concrete character U+0020 SPACE (SP) and the\n * virtual characters M-0001 VIRTUAL SPACE (VS) and M-0002 HORIZONTAL TAB (HT).\n *\n * In micromark, the actual character U+0009 CHARACTER TABULATION (HT) is\n * replaced by one M-0002 HORIZONTAL TAB (HT) and between 0 and 3 M-0001 VIRTUAL\n * SPACE (VS) characters, depending on the column at which the tab occurred.\n *\n * @param {Code} code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport function markdownSpace(code) {\n  return code === -2 || code === -1 || code === 32;\n}\n\n// Size note: removing ASCII from the regex and using `asciiPunctuation` here\n// In fact adds to the bundle size.\n/**\n * Check whether the character code represents Unicode punctuation.\n *\n * A **Unicode punctuation** is a character in the Unicode `Pc` (Punctuation,\n * Connector), `Pd` (Punctuation, Dash), `Pe` (Punctuation, Close), `Pf`\n * (Punctuation, Final quote), `Pi` (Punctuation, Initial quote), `Po`\n * (Punctuation, Other), or `Ps` (Punctuation, Open) categories, or an ASCII\n * punctuation (see `asciiPunctuation`).\n *\n * See:\n * **\\[UNICODE]**:\n * [The Unicode Standard](https://www.unicode.org/versions/).\n * Unicode Consortium.\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const unicodePunctuation = regexCheck(/\\p{P}|\\p{S}/u);\n\n/**\n * Check whether the character code represents Unicode whitespace.\n *\n * Note that this does handle micromark specific markdown whitespace characters.\n * See `markdownLineEndingOrSpace` to check that.\n *\n * A **Unicode whitespace** is a character in the Unicode `Zs` (Separator,\n * Space) category, or U+0009 CHARACTER TABULATION (HT), U+000A LINE FEED (LF),\n * U+000C (FF), or U+000D CARRIAGE RETURN (CR) (**\\[UNICODE]**).\n *\n * See:\n * **\\[UNICODE]**:\n * [The Unicode Standard](https://www.unicode.org/versions/).\n * Unicode Consortium.\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const unicodeWhitespace = regexCheck(/\\s/);\n\n/**\n * Create a code check from a regex.\n *\n * @param {RegExp} regex\n *   Expression.\n * @returns {(code: Code) => boolean}\n *   Check.\n */\nfunction regexCheck(regex) {\n  return check;\n\n  /**\n   * Check whether a code matches the bound regex.\n   *\n   * @param {Code} code\n   *   Character code.\n   * @returns {boolean}\n   *   Whether the character code matches the bound regex.\n   */\n  function check(code) {\n    return code !== null && code > -1 && regex.test(String.fromCharCode(code));\n  }\n}","/**\n * @typedef {import('hast').Element} HastElement\n * @typedef {import('hast').ElementContent} HastElementContent\n * @typedef {import('mdast-util-from-markdown').CompileContext} CompileContext\n * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension\n * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle\n * @typedef {import('mdast-util-to-markdown').Handle} ToMarkdownHandle\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension\n * @typedef {import('../index.js').InlineMath} InlineMath\n * @typedef {import('../index.js').Math} Math\n *\n * @typedef ToOptions\n *   Configuration.\n * @property {boolean | null | undefined} [singleDollarTextMath=true]\n *   Whether to support math (text) with a single dollar (default: `true`).\n *\n *   Single dollars work in Pandoc and many other places, but often interfere\n *   with “normal” dollars in text.\n *   If you turn this off, you can still use two or more dollars for text math.\n */\n\nimport {ok as assert} from 'devlop'\nimport {longestStreak} from 'longest-streak'\n\n/**\n * Create an extension for `mdast-util-from-markdown`.\n *\n * @returns {FromMarkdownExtension}\n *   Extension for `mdast-util-from-markdown`.\n */\nexport function mathFromMarkdown() {\n  return {\n    enter: {\n      mathFlow: enterMathFlow,\n      mathFlowFenceMeta: enterMathFlowMeta,\n      mathText: enterMathText\n    },\n    exit: {\n      mathFlow: exitMathFlow,\n      mathFlowFence: exitMathFlowFence,\n      mathFlowFenceMeta: exitMathFlowMeta,\n      mathFlowValue: exitMathData,\n      mathText: exitMathText,\n      mathTextData: exitMathData\n    }\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function enterMathFlow(token) {\n    /** @type {HastElement} */\n    const code = {\n      type: 'element',\n      tagName: 'code',\n      properties: {className: ['language-math', 'math-display']},\n      children: []\n    }\n    this.enter(\n      {\n        type: 'math',\n        meta: null,\n        value: '',\n        data: {hName: 'pre', hChildren: [code]}\n      },\n      token\n    )\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function enterMathFlowMeta() {\n    this.buffer()\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function exitMathFlowMeta() {\n    const data = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    assert(node.type === 'math')\n    node.meta = data\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function exitMathFlowFence() {\n    // Exit if this is the closing fence.\n    if (this.data.mathFlowInside) return\n    this.buffer()\n    this.data.mathFlowInside = true\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function exitMathFlow(token) {\n    const data = this.resume().replace(/^(\\r?\\n|\\r)|(\\r?\\n|\\r)$/g, '')\n    const node = this.stack[this.stack.length - 1]\n    assert(node.type === 'math')\n    this.exit(token)\n    node.value = data\n    // @ts-expect-error: we defined it in `enterMathFlow`.\n    const code = /** @type {HastElement} */ (node.data.hChildren[0])\n    assert(code.type === 'element')\n    assert(code.tagName === 'code')\n    code.children.push({type: 'text', value: data})\n    this.data.mathFlowInside = undefined\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function enterMathText(token) {\n    this.enter(\n      {\n        type: 'inlineMath',\n        value: '',\n        data: {\n          hName: 'code',\n          hProperties: {className: ['language-math', 'math-inline']},\n          hChildren: []\n        }\n      },\n      token\n    )\n    this.buffer()\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function exitMathText(token) {\n    const data = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    assert(node.type === 'inlineMath')\n    this.exit(token)\n    node.value = data\n    const children = /** @type {Array<HastElementContent>} */ (\n      // @ts-expect-error: we defined it in `enterMathFlow`.\n      node.data.hChildren\n    )\n    children.push({type: 'text', value: data})\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function exitMathData(token) {\n    this.config.enter.data.call(this, token)\n    this.config.exit.data.call(this, token)\n  }\n}\n\n/**\n * Create an extension for `mdast-util-to-markdown`.\n *\n * @param {ToOptions | null | undefined} [options]\n *   Configuration (optional).\n * @returns {ToMarkdownExtension}\n *   Extension for `mdast-util-to-markdown`.\n */\nexport function mathToMarkdown(options) {\n  let single = (options || {}).singleDollarTextMath\n\n  if (single === null || single === undefined) {\n    single = true\n  }\n\n  inlineMath.peek = inlineMathPeek\n\n  return {\n    unsafe: [\n      {character: '\\r', inConstruct: 'mathFlowMeta'},\n      {character: '\\n', inConstruct: 'mathFlowMeta'},\n      {\n        character: '$',\n        after: single ? undefined : '\\\\$',\n        inConstruct: 'phrasing'\n      },\n      {character: '$', inConstruct: 'mathFlowMeta'},\n      {atBreak: true, character: '$', after: '\\\\$'}\n    ],\n    handlers: {math, inlineMath}\n  }\n\n  /**\n   * @type {ToMarkdownHandle}\n   * @param {Math} node\n   */\n  // Note: fixing this code? Please also fix the similar code for code:\n  // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/main/lib/handle/code.js>\n  function math(node, _, state, info) {\n    const raw = node.value || ''\n    const tracker = state.createTracker(info)\n    const sequence = '$'.repeat(Math.max(longestStreak(raw, '$') + 1, 2))\n    const exit = state.enter('mathFlow')\n    let value = tracker.move(sequence)\n\n    if (node.meta) {\n      const subexit = state.enter('mathFlowMeta')\n      value += tracker.move(\n        state.safe(node.meta, {\n          after: '\\n',\n          before: value,\n          encode: ['$'],\n          ...tracker.current()\n        })\n      )\n      subexit()\n    }\n\n    value += tracker.move('\\n')\n\n    if (raw) {\n      value += tracker.move(raw + '\\n')\n    }\n\n    value += tracker.move(sequence)\n    exit()\n    return value\n  }\n\n  /**\n   * @type {ToMarkdownHandle}\n   * @param {InlineMath} node\n   */\n  // Note: fixing this code? Please also fix the similar code for inline code:\n  // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/main/lib/handle/inline-code.js>\n  function inlineMath(node, _, state) {\n    let value = node.value || ''\n    let size = 1\n\n    if (!single) size++\n\n    // If there is a single dollar sign on its own in the math, use a fence of\n    // two.\n    // If there are two in a row, use one.\n    while (\n      new RegExp('(^|[^$])' + '\\\\$'.repeat(size) + '([^$]|$)').test(value)\n    ) {\n      size++\n    }\n\n    const sequence = '$'.repeat(size)\n\n    // If this is not just spaces or eols (tabs don’t count), and either the\n    // first and last character are a space or eol, or the first or last\n    // character are dollar signs, then pad with spaces.\n    if (\n      // Contains non-space.\n      /[^ \\r\\n]/.test(value) &&\n      // Starts with space and ends with space.\n      ((/^[ \\r\\n]/.test(value) && /[ \\r\\n]$/.test(value)) ||\n        // Starts or ends with dollar.\n        /^\\$|\\$$/.test(value))\n    ) {\n      value = ' ' + value + ' '\n    }\n\n    let index = -1\n\n    // We have a potential problem: certain characters after eols could result in\n    // blocks being seen.\n    // For example, if someone injected the string `'\\n# b'`, then that would\n    // result in an ATX heading.\n    // We can’t escape characters in `inlineMath`, but because eols are\n    // transformed to spaces when going from markdown to HTML anyway, we can swap\n    // them out.\n    while (++index < state.unsafe.length) {\n      const pattern = state.unsafe[index]\n\n      // Only look for `atBreak`s.\n      // Btw: note that `atBreak` patterns will always start the regex at LF or\n      // CR.\n      if (!pattern.atBreak) continue\n\n      const expression = state.compilePattern(pattern)\n      /** @type {RegExpExecArray | null} */\n      let match\n\n      while ((match = expression.exec(value))) {\n        let position = match.index\n\n        // Support CRLF (patterns only look for one of the characters).\n        if (\n          value.codePointAt(position) === 10 /* `\\n` */ &&\n          value.codePointAt(position - 1) === 13 /* `\\r` */\n        ) {\n          position--\n        }\n\n        value = value.slice(0, position) + ' ' + value.slice(match.index + 1)\n      }\n    }\n\n    return sequence + value + sequence\n  }\n\n  /**\n   * @returns {string}\n   */\n  function inlineMathPeek() {\n    return '$'\n  }\n}\n","/**\n * Get the count of the longest repeating streak of `substring` in `value`.\n *\n * @param {string} value\n *   Content to search in.\n * @param {string} substring\n *   Substring to look for, typically one character.\n * @returns {number}\n *   Count of most frequent adjacent `substring`s in `value`.\n */\nexport function longestStreak(value, substring) {\n  const source = String(value)\n  let index = source.indexOf(substring)\n  let expected = index\n  let count = 0\n  let max = 0\n\n  if (typeof substring !== 'string') {\n    throw new TypeError('Expected substring')\n  }\n\n  while (index !== -1) {\n    if (index === expected) {\n      if (++count > max) {\n        max = count\n      }\n    } else {\n      count = 1\n    }\n\n    expected = index + substring.length\n    index = source.indexOf(substring, expected)\n  }\n\n  return max\n}\n","/**\n * @import {Construct, State, TokenizeContext, Tokenizer} from 'micromark-util-types'\n */\n\nimport { factorySpace } from 'micromark-factory-space';\nimport { markdownLineEnding } from 'micromark-util-character';\n/** @type {Construct} */\nexport const mathFlow = {\n  tokenize: tokenizeMathFenced,\n  concrete: true,\n  name: 'mathFlow'\n};\n\n/** @type {Construct} */\nconst nonLazyContinuation = {\n  tokenize: tokenizeNonLazyContinuation,\n  partial: true\n};\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeMathFenced(effects, ok, nok) {\n  const self = this;\n  const tail = self.events[self.events.length - 1];\n  const initialSize = tail && tail[1].type === \"linePrefix\" ? tail[2].sliceSerialize(tail[1], true).length : 0;\n  let sizeOpen = 0;\n  return start;\n\n  /**\n   * Start of math.\n   *\n   * ```markdown\n   * > | $$\n   *     ^\n   *   | \\frac{1}{2}\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    effects.enter('mathFlow');\n    effects.enter('mathFlowFence');\n    effects.enter('mathFlowFenceSequence');\n    return sequenceOpen(code);\n  }\n\n  /**\n   * In opening fence sequence.\n   *\n   * ```markdown\n   * > | $$\n   *      ^\n   *   | \\frac{1}{2}\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n  function sequenceOpen(code) {\n    if (code === 36) {\n      effects.consume(code);\n      sizeOpen++;\n      return sequenceOpen;\n    }\n    if (sizeOpen < 2) {\n      return nok(code);\n    }\n    effects.exit('mathFlowFenceSequence');\n    return factorySpace(effects, metaBefore, \"whitespace\")(code);\n  }\n\n  /**\n   * In opening fence, before meta.\n   *\n   * ```markdown\n   * > | $$asciimath\n   *       ^\n   *   | x < y\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n\n  function metaBefore(code) {\n    if (code === null || markdownLineEnding(code)) {\n      return metaAfter(code);\n    }\n    effects.enter('mathFlowFenceMeta');\n    effects.enter(\"chunkString\", {\n      contentType: \"string\"\n    });\n    return meta(code);\n  }\n\n  /**\n   * In meta.\n   *\n   * ```markdown\n   * > | $$asciimath\n   *        ^\n   *   | x < y\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n  function meta(code) {\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit(\"chunkString\");\n      effects.exit('mathFlowFenceMeta');\n      return metaAfter(code);\n    }\n    if (code === 36) {\n      return nok(code);\n    }\n    effects.consume(code);\n    return meta;\n  }\n\n  /**\n   * After meta.\n   *\n   * ```markdown\n   * > | $$\n   *       ^\n   *   | \\frac{1}{2}\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n  function metaAfter(code) {\n    // Guaranteed to be eol/eof.\n    effects.exit('mathFlowFence');\n    if (self.interrupt) {\n      return ok(code);\n    }\n    return effects.attempt(nonLazyContinuation, beforeNonLazyContinuation, after)(code);\n  }\n\n  /**\n   * After eol/eof in math, at a non-lazy closing fence or content.\n   *\n   * ```markdown\n   *   | $$\n   * > | \\frac{1}{2}\n   *     ^\n   * > | $$\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function beforeNonLazyContinuation(code) {\n    return effects.attempt({\n      tokenize: tokenizeClosingFence,\n      partial: true\n    }, after, contentStart)(code);\n  }\n\n  /**\n   * Before math content, definitely not before a closing fence.\n   *\n   * ```markdown\n   *   | $$\n   * > | \\frac{1}{2}\n   *     ^\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n  function contentStart(code) {\n    return (initialSize ? factorySpace(effects, beforeContentChunk, \"linePrefix\", initialSize + 1) : beforeContentChunk)(code);\n  }\n\n  /**\n   * Before math content, after optional prefix.\n   *\n   * ```markdown\n   *   | $$\n   * > | \\frac{1}{2}\n   *     ^\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n  function beforeContentChunk(code) {\n    if (code === null) {\n      return after(code);\n    }\n    if (markdownLineEnding(code)) {\n      return effects.attempt(nonLazyContinuation, beforeNonLazyContinuation, after)(code);\n    }\n    effects.enter('mathFlowValue');\n    return contentChunk(code);\n  }\n\n  /**\n   * In math content.\n   *\n   * ```markdown\n   *   | $$\n   * > | \\frac{1}{2}\n   *      ^\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n  function contentChunk(code) {\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit('mathFlowValue');\n      return beforeContentChunk(code);\n    }\n    effects.consume(code);\n    return contentChunk;\n  }\n\n  /**\n   * After math (ha!).\n   *\n   * ```markdown\n   *   | $$\n   *   | \\frac{1}{2}\n   * > | $$\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function after(code) {\n    effects.exit('mathFlow');\n    return ok(code);\n  }\n\n  /** @type {Tokenizer} */\n  function tokenizeClosingFence(effects, ok, nok) {\n    let size = 0;\n    /**\n     * Before closing fence, at optional whitespace.\n     *\n     * ```markdown\n     *   | $$\n     *   | \\frac{1}{2}\n     * > | $$\n     *     ^\n     * ```\n     */\n    return factorySpace(effects, beforeSequenceClose, \"linePrefix\", self.parser.constructs.disable.null.includes('codeIndented') ? undefined : 4);\n\n    /**\n     * In closing fence, after optional whitespace, at sequence.\n     *\n     * ```markdown\n     *   | $$\n     *   | \\frac{1}{2}\n     * > | $$\n     *     ^\n     * ```\n     *\n     * @type {State}\n     */\n    function beforeSequenceClose(code) {\n      effects.enter('mathFlowFence');\n      effects.enter('mathFlowFenceSequence');\n      return sequenceClose(code);\n    }\n\n    /**\n     * In closing fence sequence.\n     *\n     * ```markdown\n     *   | $$\n     *   | \\frac{1}{2}\n     * > | $$\n     *      ^\n     * ```\n     *\n     * @type {State}\n     */\n    function sequenceClose(code) {\n      if (code === 36) {\n        size++;\n        effects.consume(code);\n        return sequenceClose;\n      }\n      if (size < sizeOpen) {\n        return nok(code);\n      }\n      effects.exit('mathFlowFenceSequence');\n      return factorySpace(effects, afterSequenceClose, \"whitespace\")(code);\n    }\n\n    /**\n     * After closing fence sequence, after optional whitespace.\n     *\n     * ```markdown\n     *   | $$\n     *   | \\frac{1}{2}\n     * > | $$\n     *       ^\n     * ```\n     *\n     * @type {State}\n     */\n    function afterSequenceClose(code) {\n      if (code === null || markdownLineEnding(code)) {\n        effects.exit('mathFlowFence');\n        return ok(code);\n      }\n      return nok(code);\n    }\n  }\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeNonLazyContinuation(effects, ok, nok) {\n  const self = this;\n  return start;\n\n  /** @type {State} */\n  function start(code) {\n    if (code === null) {\n      return ok(code);\n    }\n    effects.enter(\"lineEnding\");\n    effects.consume(code);\n    effects.exit(\"lineEnding\");\n    return lineStart;\n  }\n\n  /** @type {State} */\n  function lineStart(code) {\n    return self.parser.lazy[self.now().line] ? nok(code) : ok(code);\n  }\n}","/**\n * @import {Options} from 'micromark-extension-math'\n * @import {Construct, Previous, Resolver, State, Token, TokenizeContext, Tokenizer} from 'micromark-util-types'\n */\n\n// To do: next major: clean spaces in HTML compiler.\n// This has to be coordinated together with `mdast-util-math`.\n\nimport { markdownLineEnding } from 'micromark-util-character';\n/**\n * @param {Options | null | undefined} [options={}]\n *   Configuration (default: `{}`).\n * @returns {Construct}\n *   Construct.\n */\nexport function mathText(options) {\n  const options_ = options || {};\n  let single = options_.singleDollarTextMath;\n  if (single === null || single === undefined) {\n    single = true;\n  }\n  return {\n    tokenize: tokenizeMathText,\n    resolve: resolveMathText,\n    previous,\n    name: 'mathText'\n  };\n\n  /**\n   * @this {TokenizeContext}\n   * @type {Tokenizer}\n   */\n  function tokenizeMathText(effects, ok, nok) {\n    const self = this;\n    let sizeOpen = 0;\n    /** @type {number} */\n    let size;\n    /** @type {Token} */\n    let token;\n    return start;\n\n    /**\n     * Start of math (text).\n     *\n     * ```markdown\n     * > | $a$\n     *     ^\n     * > | \\$a$\n     *      ^\n     * ```\n     *\n     * @type {State}\n     */\n    function start(code) {\n      effects.enter('mathText');\n      effects.enter('mathTextSequence');\n      return sequenceOpen(code);\n    }\n\n    /**\n     * In opening sequence.\n     *\n     * ```markdown\n     * > | $a$\n     *     ^\n     * ```\n     *\n     * @type {State}\n     */\n\n    function sequenceOpen(code) {\n      if (code === 36) {\n        effects.consume(code);\n        sizeOpen++;\n        return sequenceOpen;\n      }\n\n      // Not enough markers in the sequence.\n      if (sizeOpen < 2 && !single) {\n        return nok(code);\n      }\n      effects.exit('mathTextSequence');\n      return between(code);\n    }\n\n    /**\n     * Between something and something else.\n     *\n     * ```markdown\n     * > | $a$\n     *      ^^\n     * ```\n     *\n     * @type {State}\n     */\n    function between(code) {\n      if (code === null) {\n        return nok(code);\n      }\n      if (code === 36) {\n        token = effects.enter('mathTextSequence');\n        size = 0;\n        return sequenceClose(code);\n      }\n\n      // Tabs don’t work, and virtual spaces don’t make sense.\n      if (code === 32) {\n        effects.enter('space');\n        effects.consume(code);\n        effects.exit('space');\n        return between;\n      }\n      if (markdownLineEnding(code)) {\n        effects.enter(\"lineEnding\");\n        effects.consume(code);\n        effects.exit(\"lineEnding\");\n        return between;\n      }\n\n      // Data.\n      effects.enter('mathTextData');\n      return data(code);\n    }\n\n    /**\n     * In data.\n     *\n     * ```markdown\n     * > | $a$\n     *      ^\n     * ```\n     *\n     * @type {State}\n     */\n    function data(code) {\n      if (code === null || code === 32 || code === 36 || markdownLineEnding(code)) {\n        effects.exit('mathTextData');\n        return between(code);\n      }\n      effects.consume(code);\n      return data;\n    }\n\n    /**\n     * In closing sequence.\n     *\n     * ```markdown\n     * > | `a`\n     *       ^\n     * ```\n     *\n     * @type {State}\n     */\n\n    function sequenceClose(code) {\n      // More.\n      if (code === 36) {\n        effects.consume(code);\n        size++;\n        return sequenceClose;\n      }\n\n      // Done!\n      if (size === sizeOpen) {\n        effects.exit('mathTextSequence');\n        effects.exit('mathText');\n        return ok(code);\n      }\n\n      // More or less accents: mark as data.\n      token.type = 'mathTextData';\n      return data(code);\n    }\n  }\n}\n\n/** @type {Resolver} */\nfunction resolveMathText(events) {\n  let tailExitIndex = events.length - 4;\n  let headEnterIndex = 3;\n  /** @type {number} */\n  let index;\n  /** @type {number | undefined} */\n  let enter;\n\n  // If we start and end with an EOL or a space.\n  if ((events[headEnterIndex][1].type === \"lineEnding\" || events[headEnterIndex][1].type === 'space') && (events[tailExitIndex][1].type === \"lineEnding\" || events[tailExitIndex][1].type === 'space')) {\n    index = headEnterIndex;\n\n    // And we have data.\n    while (++index < tailExitIndex) {\n      if (events[index][1].type === 'mathTextData') {\n        // Then we have padding.\n        events[tailExitIndex][1].type = 'mathTextPadding';\n        events[headEnterIndex][1].type = 'mathTextPadding';\n        headEnterIndex += 2;\n        tailExitIndex -= 2;\n        break;\n      }\n    }\n  }\n\n  // Merge adjacent spaces and data.\n  index = headEnterIndex - 1;\n  tailExitIndex++;\n  while (++index <= tailExitIndex) {\n    if (enter === undefined) {\n      if (index !== tailExitIndex && events[index][1].type !== \"lineEnding\") {\n        enter = index;\n      }\n    } else if (index === tailExitIndex || events[index][1].type === \"lineEnding\") {\n      events[enter][1].type = 'mathTextData';\n      if (index !== enter + 2) {\n        events[enter][1].end = events[index - 1][1].end;\n        events.splice(enter + 2, index - enter - 2);\n        tailExitIndex -= index - enter - 2;\n        index = enter + 2;\n      }\n      enter = undefined;\n    }\n  }\n  return events;\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Previous}\n */\nfunction previous(code) {\n  // If there is a previous code, there will always be a tail.\n  return code !== 36 || this.events[this.events.length - 1][1].type === \"characterEscape\";\n}","/// <reference types=\"mdast-util-math\" />\n/// <reference types=\"remark-parse\" />\n/// <reference types=\"remark-stringify\" />\n\n/**\n * @typedef {import('mdast').Root} Root\n * @typedef {import('mdast-util-math').ToOptions} Options\n * @typedef {import('unified').Processor<Root>} Processor\n */\n\nimport {mathFromMarkdown, mathToMarkdown} from 'mdast-util-math'\nimport {math} from 'micromark-extension-math'\n\n/** @type {Readonly<Options>} */\nconst emptyOptions = {}\n\n/**\n * Add support for math.\n *\n * @param {Readonly<Options> | null | undefined} [options]\n *   Configuration (optional).\n * @returns {undefined}\n *   Nothing.\n */\nexport default function remarkMath(options) {\n  // @ts-expect-error: TS is wrong about `this`.\n  // eslint-disable-next-line unicorn/no-this-assignment\n  const self = /** @type {Processor} */ (this)\n  const settings = options || emptyOptions\n  const data = self.data()\n\n  const micromarkExtensions =\n    data.micromarkExtensions || (data.micromarkExtensions = [])\n  const fromMarkdownExtensions =\n    data.fromMarkdownExtensions || (data.fromMarkdownExtensions = [])\n  const toMarkdownExtensions =\n    data.toMarkdownExtensions || (data.toMarkdownExtensions = [])\n\n  micromarkExtensions.push(math(settings))\n  fromMarkdownExtensions.push(mathFromMarkdown())\n  toMarkdownExtensions.push(mathToMarkdown(settings))\n}\n","/**\n * @import {Options} from 'micromark-extension-math'\n * @import {Extension} from 'micromark-util-types'\n */\n\nimport { mathFlow } from './math-flow.js';\nimport { mathText } from './math-text.js';\n\n/**\n * Create an extension for `micromark` to enable math syntax.\n *\n * @param {Options | null | undefined} [options={}]\n *   Configuration (default: `{}`).\n * @returns {Extension}\n *   Extension for `micromark` that can be passed in `extensions`, to\n *   enable math syntax.\n */\nexport function math(options) {\n  return {\n    flow: {\n      [36]: mathFlow\n    },\n    text: {\n      [36]: mathText(options)\n    }\n  };\n}","/**\n * @import {Effects, State, TokenType} from 'micromark-util-types'\n */\n\nimport { markdownSpace } from 'micromark-util-character';\n\n// To do: implement `spaceOrTab`, `spaceOrTabMinMax`, `spaceOrTabWithOptions`.\n\n/**\n * Parse spaces and tabs.\n *\n * There is no `nok` parameter:\n *\n * *   spaces in markdown are often optional, in which case this factory can be\n *     used and `ok` will be switched to whether spaces were found or not\n * *   one line ending or space can be detected with `markdownSpace(code)` right\n *     before using `factorySpace`\n *\n * ###### Examples\n *\n * Where `␉` represents a tab (plus how much it expands) and `␠` represents a\n * single space.\n *\n * ```markdown\n * ␉\n * ␠␠␠␠\n * ␉␠\n * ```\n *\n * @param {Effects} effects\n *   Context.\n * @param {State} ok\n *   State switched to when successful.\n * @param {TokenType} type\n *   Type (`' \\t'`).\n * @param {number | undefined} [max=Infinity]\n *   Max (exclusive).\n * @returns {State}\n *   Start state.\n */\nexport function factorySpace(effects, ok, type, max) {\n  const limit = max ? max - 1 : Number.POSITIVE_INFINITY;\n  let size = 0;\n  return start;\n\n  /** @type {State} */\n  function start(code) {\n    if (markdownSpace(code)) {\n      effects.enter(type);\n      return prefix(code);\n    }\n    return ok(code);\n  }\n\n  /** @type {State} */\n  function prefix(code) {\n    if (markdownSpace(code) && size++ < limit) {\n      effects.consume(code);\n      return prefix;\n    }\n    effects.exit(type);\n    return ok(code);\n  }\n}"],"names":["ok","unreachable","asciiAlpha","regexCheck","asciiAlphanumeric","asciiAtext","asciiControl","code","asciiDigit","asciiHexDigit","asciiPunctuation","markdownLineEnding","markdownLineEndingOrSpace","markdownSpace","unicodePunctuation","unicodeWhitespace","regex","test","String","fromCharCode","mathToMarkdown","options","single","singleDollarTextMath","undefined","inlineMath","peek","unsafe","character","inConstruct","after","atBreak","handlers","math","node","_","state","info","raw","value","tracker","createTracker","sequence","repeat","Math","max","substring","source","index","indexOf","expected","count","TypeError","length","longestStreak","exit","enter","move","meta","subexit","safe","_objectSpread","before","encode","current","size","RegExp","pattern","expression","compilePattern","match","exec","position","codePointAt","slice","mathFlow","tokenize","effects","nok","self","this","tail","events","initialSize","type","sliceSerialize","sizeOpen","sequenceOpen","consume","factorySpace","metaBefore","metaAfter","contentType","interrupt","attempt","nonLazyContinuation","beforeNonLazyContinuation","tokenizeClosingFence","partial","contentStart","beforeContentChunk","contentChunk","sequenceClose","parser","constructs","disable","null","includes","afterSequenceClose","concrete","name","lineStart","lazy","now","line","mathText","token","between","data","resolve","resolveMathText","previous","tailExitIndex","headEnterIndex","end","splice","emptyOptions","remarkMath","settings","micromarkExtensions","fromMarkdownExtensions","toMarkdownExtensions","push","flow","text","hName","hChildren","tagName","properties","className","children","mathFlowFenceMeta","buffer","hProperties","resume","replace","stack","assert","mathFlowInside","mathFlowFence","mathFlowValue","exitMathData","mathTextData","config","call","mathFromMarkdown","limit","Number","POSITIVE_INFINITY","prefix"],"sourceRoot":""}