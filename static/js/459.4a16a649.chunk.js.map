{"version":3,"file":"static/js/459.4a16a649.chunk.js","mappings":"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","sources":["../node_modules/devlop/lib/default.js","../node_modules/micromark-factory-space/index.js","../node_modules/micromark-util-character/index.js","../node_modules/mdast-util-math/lib/index.js","../node_modules/longest-streak/index.js","../node_modules/micromark-extension-math/lib/math-flow.js","../node_modules/micromark-extension-math/lib/math-text.js","../node_modules/remark-math/lib/index.js","../node_modules/micromark-extension-math/lib/syntax.js"],"sourcesContent":["export function deprecate(fn) {\n  return fn\n}\n\nexport function equal() {}\n\nexport function ok() {}\n\nexport function unreachable() {}\n","/**\n * @import {Effects, State, TokenType} from 'micromark-util-types'\n */\n\nimport { markdownSpace } from 'micromark-util-character';\n\n// To do: implement `spaceOrTab`, `spaceOrTabMinMax`, `spaceOrTabWithOptions`.\n\n/**\n * Parse spaces and tabs.\n *\n * There is no `nok` parameter:\n *\n * *   spaces in markdown are often optional, in which case this factory can be\n *     used and `ok` will be switched to whether spaces were found or not\n * *   one line ending or space can be detected with `markdownSpace(code)` right\n *     before using `factorySpace`\n *\n * ###### Examples\n *\n * Where `␉` represents a tab (plus how much it expands) and `␠` represents a\n * single space.\n *\n * ```markdown\n * ␉\n * ␠␠␠␠\n * ␉␠\n * ```\n *\n * @param {Effects} effects\n *   Context.\n * @param {State} ok\n *   State switched to when successful.\n * @param {TokenType} type\n *   Type (`' \\t'`).\n * @param {number | undefined} [max=Infinity]\n *   Max (exclusive).\n * @returns {State}\n *   Start state.\n */\nexport function factorySpace(effects, ok, type, max) {\n  const limit = max ? max - 1 : Number.POSITIVE_INFINITY;\n  let size = 0;\n  return start;\n\n  /** @type {State} */\n  function start(code) {\n    if (markdownSpace(code)) {\n      effects.enter(type);\n      return prefix(code);\n    }\n    return ok(code);\n  }\n\n  /** @type {State} */\n  function prefix(code) {\n    if (markdownSpace(code) && size++ < limit) {\n      effects.consume(code);\n      return prefix;\n    }\n    effects.exit(type);\n    return ok(code);\n  }\n}","/**\n * @import {Code} from 'micromark-util-types'\n */\n\n/**\n * Check whether the character code represents an ASCII alpha (`a` through `z`,\n * case insensitive).\n *\n * An **ASCII alpha** is an ASCII upper alpha or ASCII lower alpha.\n *\n * An **ASCII upper alpha** is a character in the inclusive range U+0041 (`A`)\n * to U+005A (`Z`).\n *\n * An **ASCII lower alpha** is a character in the inclusive range U+0061 (`a`)\n * to U+007A (`z`).\n *\n * @param code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport const asciiAlpha = regexCheck(/[A-Za-z]/);\n\n/**\n * Check whether the character code represents an ASCII alphanumeric (`a`\n * through `z`, case insensitive, or `0` through `9`).\n *\n * An **ASCII alphanumeric** is an ASCII digit (see `asciiDigit`) or ASCII alpha\n * (see `asciiAlpha`).\n *\n * @param code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport const asciiAlphanumeric = regexCheck(/[\\dA-Za-z]/);\n\n/**\n * Check whether the character code represents an ASCII atext.\n *\n * atext is an ASCII alphanumeric (see `asciiAlphanumeric`), or a character in\n * the inclusive ranges U+0023 NUMBER SIGN (`#`) to U+0027 APOSTROPHE (`'`),\n * U+002A ASTERISK (`*`), U+002B PLUS SIGN (`+`), U+002D DASH (`-`), U+002F\n * SLASH (`/`), U+003D EQUALS TO (`=`), U+003F QUESTION MARK (`?`), U+005E\n * CARET (`^`) to U+0060 GRAVE ACCENT (`` ` ``), or U+007B LEFT CURLY BRACE\n * (`{`) to U+007E TILDE (`~`).\n *\n * See:\n * **\\[RFC5322]**:\n * [Internet Message Format](https://tools.ietf.org/html/rfc5322).\n * P. Resnick.\n * IETF.\n *\n * @param code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport const asciiAtext = regexCheck(/[#-'*+\\--9=?A-Z^-~]/);\n\n/**\n * Check whether a character code is an ASCII control character.\n *\n * An **ASCII control** is a character in the inclusive range U+0000 NULL (NUL)\n * to U+001F (US), or U+007F (DEL).\n *\n * @param {Code} code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport function asciiControl(code) {\n  return (\n    // Special whitespace codes (which have negative values), C0 and Control\n    // character DEL\n    code !== null && (code < 32 || code === 127)\n  );\n}\n\n/**\n * Check whether the character code represents an ASCII digit (`0` through `9`).\n *\n * An **ASCII digit** is a character in the inclusive range U+0030 (`0`) to\n * U+0039 (`9`).\n *\n * @param code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport const asciiDigit = regexCheck(/\\d/);\n\n/**\n * Check whether the character code represents an ASCII hex digit (`a` through\n * `f`, case insensitive, or `0` through `9`).\n *\n * An **ASCII hex digit** is an ASCII digit (see `asciiDigit`), ASCII upper hex\n * digit, or an ASCII lower hex digit.\n *\n * An **ASCII upper hex digit** is a character in the inclusive range U+0041\n * (`A`) to U+0046 (`F`).\n *\n * An **ASCII lower hex digit** is a character in the inclusive range U+0061\n * (`a`) to U+0066 (`f`).\n *\n * @param code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport const asciiHexDigit = regexCheck(/[\\dA-Fa-f]/);\n\n/**\n * Check whether the character code represents ASCII punctuation.\n *\n * An **ASCII punctuation** is a character in the inclusive ranges U+0021\n * EXCLAMATION MARK (`!`) to U+002F SLASH (`/`), U+003A COLON (`:`) to U+0040 AT\n * SIGN (`@`), U+005B LEFT SQUARE BRACKET (`[`) to U+0060 GRAVE ACCENT\n * (`` ` ``), or U+007B LEFT CURLY BRACE (`{`) to U+007E TILDE (`~`).\n *\n * @param code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport const asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/);\n\n/**\n * Check whether a character code is a markdown line ending.\n *\n * A **markdown line ending** is the virtual characters M-0003 CARRIAGE RETURN\n * LINE FEED (CRLF), M-0004 LINE FEED (LF) and M-0005 CARRIAGE RETURN (CR).\n *\n * In micromark, the actual character U+000A LINE FEED (LF) and U+000D CARRIAGE\n * RETURN (CR) are replaced by these virtual characters depending on whether\n * they occurred together.\n *\n * @param {Code} code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport function markdownLineEnding(code) {\n  return code !== null && code < -2;\n}\n\n/**\n * Check whether a character code is a markdown line ending (see\n * `markdownLineEnding`) or markdown space (see `markdownSpace`).\n *\n * @param {Code} code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport function markdownLineEndingOrSpace(code) {\n  return code !== null && (code < 0 || code === 32);\n}\n\n/**\n * Check whether a character code is a markdown space.\n *\n * A **markdown space** is the concrete character U+0020 SPACE (SP) and the\n * virtual characters M-0001 VIRTUAL SPACE (VS) and M-0002 HORIZONTAL TAB (HT).\n *\n * In micromark, the actual character U+0009 CHARACTER TABULATION (HT) is\n * replaced by one M-0002 HORIZONTAL TAB (HT) and between 0 and 3 M-0001 VIRTUAL\n * SPACE (VS) characters, depending on the column at which the tab occurred.\n *\n * @param {Code} code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport function markdownSpace(code) {\n  return code === -2 || code === -1 || code === 32;\n}\n\n// Size note: removing ASCII from the regex and using `asciiPunctuation` here\n// In fact adds to the bundle size.\n/**\n * Check whether the character code represents Unicode punctuation.\n *\n * A **Unicode punctuation** is a character in the Unicode `Pc` (Punctuation,\n * Connector), `Pd` (Punctuation, Dash), `Pe` (Punctuation, Close), `Pf`\n * (Punctuation, Final quote), `Pi` (Punctuation, Initial quote), `Po`\n * (Punctuation, Other), or `Ps` (Punctuation, Open) categories, or an ASCII\n * punctuation (see `asciiPunctuation`).\n *\n * See:\n * **\\[UNICODE]**:\n * [The Unicode Standard](https://www.unicode.org/versions/).\n * Unicode Consortium.\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const unicodePunctuation = regexCheck(/\\p{P}|\\p{S}/u);\n\n/**\n * Check whether the character code represents Unicode whitespace.\n *\n * Note that this does handle micromark specific markdown whitespace characters.\n * See `markdownLineEndingOrSpace` to check that.\n *\n * A **Unicode whitespace** is a character in the Unicode `Zs` (Separator,\n * Space) category, or U+0009 CHARACTER TABULATION (HT), U+000A LINE FEED (LF),\n * U+000C (FF), or U+000D CARRIAGE RETURN (CR) (**\\[UNICODE]**).\n *\n * See:\n * **\\[UNICODE]**:\n * [The Unicode Standard](https://www.unicode.org/versions/).\n * Unicode Consortium.\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const unicodeWhitespace = regexCheck(/\\s/);\n\n/**\n * Create a code check from a regex.\n *\n * @param {RegExp} regex\n *   Expression.\n * @returns {(code: Code) => boolean}\n *   Check.\n */\nfunction regexCheck(regex) {\n  return check;\n\n  /**\n   * Check whether a code matches the bound regex.\n   *\n   * @param {Code} code\n   *   Character code.\n   * @returns {boolean}\n   *   Whether the character code matches the bound regex.\n   */\n  function check(code) {\n    return code !== null && code > -1 && regex.test(String.fromCharCode(code));\n  }\n}","/**\n * @typedef {import('hast').Element} HastElement\n * @typedef {import('hast').ElementContent} HastElementContent\n * @typedef {import('mdast-util-from-markdown').CompileContext} CompileContext\n * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension\n * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle\n * @typedef {import('mdast-util-to-markdown').Handle} ToMarkdownHandle\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension\n * @typedef {import('../index.js').InlineMath} InlineMath\n * @typedef {import('../index.js').Math} Math\n *\n * @typedef ToOptions\n *   Configuration.\n * @property {boolean | null | undefined} [singleDollarTextMath=true]\n *   Whether to support math (text) with a single dollar (default: `true`).\n *\n *   Single dollars work in Pandoc and many other places, but often interfere\n *   with “normal” dollars in text.\n *   If you turn this off, you can still use two or more dollars for text math.\n */\n\nimport {ok as assert} from 'devlop'\nimport {longestStreak} from 'longest-streak'\n\n/**\n * Create an extension for `mdast-util-from-markdown`.\n *\n * @returns {FromMarkdownExtension}\n *   Extension for `mdast-util-from-markdown`.\n */\nexport function mathFromMarkdown() {\n  return {\n    enter: {\n      mathFlow: enterMathFlow,\n      mathFlowFenceMeta: enterMathFlowMeta,\n      mathText: enterMathText\n    },\n    exit: {\n      mathFlow: exitMathFlow,\n      mathFlowFence: exitMathFlowFence,\n      mathFlowFenceMeta: exitMathFlowMeta,\n      mathFlowValue: exitMathData,\n      mathText: exitMathText,\n      mathTextData: exitMathData\n    }\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function enterMathFlow(token) {\n    /** @type {HastElement} */\n    const code = {\n      type: 'element',\n      tagName: 'code',\n      properties: {className: ['language-math', 'math-display']},\n      children: []\n    }\n    this.enter(\n      {\n        type: 'math',\n        meta: null,\n        value: '',\n        data: {hName: 'pre', hChildren: [code]}\n      },\n      token\n    )\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function enterMathFlowMeta() {\n    this.buffer()\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function exitMathFlowMeta() {\n    const data = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    assert(node.type === 'math')\n    node.meta = data\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function exitMathFlowFence() {\n    // Exit if this is the closing fence.\n    if (this.data.mathFlowInside) return\n    this.buffer()\n    this.data.mathFlowInside = true\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function exitMathFlow(token) {\n    const data = this.resume().replace(/^(\\r?\\n|\\r)|(\\r?\\n|\\r)$/g, '')\n    const node = this.stack[this.stack.length - 1]\n    assert(node.type === 'math')\n    this.exit(token)\n    node.value = data\n    // @ts-expect-error: we defined it in `enterMathFlow`.\n    const code = /** @type {HastElement} */ (node.data.hChildren[0])\n    assert(code.type === 'element')\n    assert(code.tagName === 'code')\n    code.children.push({type: 'text', value: data})\n    this.data.mathFlowInside = undefined\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function enterMathText(token) {\n    this.enter(\n      {\n        type: 'inlineMath',\n        value: '',\n        data: {\n          hName: 'code',\n          hProperties: {className: ['language-math', 'math-inline']},\n          hChildren: []\n        }\n      },\n      token\n    )\n    this.buffer()\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function exitMathText(token) {\n    const data = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    assert(node.type === 'inlineMath')\n    this.exit(token)\n    node.value = data\n    const children = /** @type {Array<HastElementContent>} */ (\n      // @ts-expect-error: we defined it in `enterMathFlow`.\n      node.data.hChildren\n    )\n    children.push({type: 'text', value: data})\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function exitMathData(token) {\n    this.config.enter.data.call(this, token)\n    this.config.exit.data.call(this, token)\n  }\n}\n\n/**\n * Create an extension for `mdast-util-to-markdown`.\n *\n * @param {ToOptions | null | undefined} [options]\n *   Configuration (optional).\n * @returns {ToMarkdownExtension}\n *   Extension for `mdast-util-to-markdown`.\n */\nexport function mathToMarkdown(options) {\n  let single = (options || {}).singleDollarTextMath\n\n  if (single === null || single === undefined) {\n    single = true\n  }\n\n  inlineMath.peek = inlineMathPeek\n\n  return {\n    unsafe: [\n      {character: '\\r', inConstruct: 'mathFlowMeta'},\n      {character: '\\n', inConstruct: 'mathFlowMeta'},\n      {\n        character: '$',\n        after: single ? undefined : '\\\\$',\n        inConstruct: 'phrasing'\n      },\n      {character: '$', inConstruct: 'mathFlowMeta'},\n      {atBreak: true, character: '$', after: '\\\\$'}\n    ],\n    handlers: {math, inlineMath}\n  }\n\n  /**\n   * @type {ToMarkdownHandle}\n   * @param {Math} node\n   */\n  // Note: fixing this code? Please also fix the similar code for code:\n  // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/main/lib/handle/code.js>\n  function math(node, _, state, info) {\n    const raw = node.value || ''\n    const tracker = state.createTracker(info)\n    const sequence = '$'.repeat(Math.max(longestStreak(raw, '$') + 1, 2))\n    const exit = state.enter('mathFlow')\n    let value = tracker.move(sequence)\n\n    if (node.meta) {\n      const subexit = state.enter('mathFlowMeta')\n      value += tracker.move(\n        state.safe(node.meta, {\n          after: '\\n',\n          before: value,\n          encode: ['$'],\n          ...tracker.current()\n        })\n      )\n      subexit()\n    }\n\n    value += tracker.move('\\n')\n\n    if (raw) {\n      value += tracker.move(raw + '\\n')\n    }\n\n    value += tracker.move(sequence)\n    exit()\n    return value\n  }\n\n  /**\n   * @type {ToMarkdownHandle}\n   * @param {InlineMath} node\n   */\n  // Note: fixing this code? Please also fix the similar code for inline code:\n  // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/main/lib/handle/inline-code.js>\n  function inlineMath(node, _, state) {\n    let value = node.value || ''\n    let size = 1\n\n    if (!single) size++\n\n    // If there is a single dollar sign on its own in the math, use a fence of\n    // two.\n    // If there are two in a row, use one.\n    while (\n      new RegExp('(^|[^$])' + '\\\\$'.repeat(size) + '([^$]|$)').test(value)\n    ) {\n      size++\n    }\n\n    const sequence = '$'.repeat(size)\n\n    // If this is not just spaces or eols (tabs don’t count), and either the\n    // first and last character are a space or eol, or the first or last\n    // character are dollar signs, then pad with spaces.\n    if (\n      // Contains non-space.\n      /[^ \\r\\n]/.test(value) &&\n      // Starts with space and ends with space.\n      ((/^[ \\r\\n]/.test(value) && /[ \\r\\n]$/.test(value)) ||\n        // Starts or ends with dollar.\n        /^\\$|\\$$/.test(value))\n    ) {\n      value = ' ' + value + ' '\n    }\n\n    let index = -1\n\n    // We have a potential problem: certain characters after eols could result in\n    // blocks being seen.\n    // For example, if someone injected the string `'\\n# b'`, then that would\n    // result in an ATX heading.\n    // We can’t escape characters in `inlineMath`, but because eols are\n    // transformed to spaces when going from markdown to HTML anyway, we can swap\n    // them out.\n    while (++index < state.unsafe.length) {\n      const pattern = state.unsafe[index]\n\n      // Only look for `atBreak`s.\n      // Btw: note that `atBreak` patterns will always start the regex at LF or\n      // CR.\n      if (!pattern.atBreak) continue\n\n      const expression = state.compilePattern(pattern)\n      /** @type {RegExpExecArray | null} */\n      let match\n\n      while ((match = expression.exec(value))) {\n        let position = match.index\n\n        // Support CRLF (patterns only look for one of the characters).\n        if (\n          value.codePointAt(position) === 10 /* `\\n` */ &&\n          value.codePointAt(position - 1) === 13 /* `\\r` */\n        ) {\n          position--\n        }\n\n        value = value.slice(0, position) + ' ' + value.slice(match.index + 1)\n      }\n    }\n\n    return sequence + value + sequence\n  }\n\n  /**\n   * @returns {string}\n   */\n  function inlineMathPeek() {\n    return '$'\n  }\n}\n","/**\n * Get the count of the longest repeating streak of `substring` in `value`.\n *\n * @param {string} value\n *   Content to search in.\n * @param {string} substring\n *   Substring to look for, typically one character.\n * @returns {number}\n *   Count of most frequent adjacent `substring`s in `value`.\n */\nexport function longestStreak(value, substring) {\n  const source = String(value)\n  let index = source.indexOf(substring)\n  let expected = index\n  let count = 0\n  let max = 0\n\n  if (typeof substring !== 'string') {\n    throw new TypeError('Expected substring')\n  }\n\n  while (index !== -1) {\n    if (index === expected) {\n      if (++count > max) {\n        max = count\n      }\n    } else {\n      count = 1\n    }\n\n    expected = index + substring.length\n    index = source.indexOf(substring, expected)\n  }\n\n  return max\n}\n","/**\n * @import {Construct, State, TokenizeContext, Tokenizer} from 'micromark-util-types'\n */\n\nimport { factorySpace } from 'micromark-factory-space';\nimport { markdownLineEnding } from 'micromark-util-character';\n/** @type {Construct} */\nexport const mathFlow = {\n  tokenize: tokenizeMathFenced,\n  concrete: true,\n  name: 'mathFlow'\n};\n\n/** @type {Construct} */\nconst nonLazyContinuation = {\n  tokenize: tokenizeNonLazyContinuation,\n  partial: true\n};\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeMathFenced(effects, ok, nok) {\n  const self = this;\n  const tail = self.events[self.events.length - 1];\n  const initialSize = tail && tail[1].type === \"linePrefix\" ? tail[2].sliceSerialize(tail[1], true).length : 0;\n  let sizeOpen = 0;\n  return start;\n\n  /**\n   * Start of math.\n   *\n   * ```markdown\n   * > | $$\n   *     ^\n   *   | \\frac{1}{2}\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    effects.enter('mathFlow');\n    effects.enter('mathFlowFence');\n    effects.enter('mathFlowFenceSequence');\n    return sequenceOpen(code);\n  }\n\n  /**\n   * In opening fence sequence.\n   *\n   * ```markdown\n   * > | $$\n   *      ^\n   *   | \\frac{1}{2}\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n  function sequenceOpen(code) {\n    if (code === 36) {\n      effects.consume(code);\n      sizeOpen++;\n      return sequenceOpen;\n    }\n    if (sizeOpen < 2) {\n      return nok(code);\n    }\n    effects.exit('mathFlowFenceSequence');\n    return factorySpace(effects, metaBefore, \"whitespace\")(code);\n  }\n\n  /**\n   * In opening fence, before meta.\n   *\n   * ```markdown\n   * > | $$asciimath\n   *       ^\n   *   | x < y\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n\n  function metaBefore(code) {\n    if (code === null || markdownLineEnding(code)) {\n      return metaAfter(code);\n    }\n    effects.enter('mathFlowFenceMeta');\n    effects.enter(\"chunkString\", {\n      contentType: \"string\"\n    });\n    return meta(code);\n  }\n\n  /**\n   * In meta.\n   *\n   * ```markdown\n   * > | $$asciimath\n   *        ^\n   *   | x < y\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n  function meta(code) {\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit(\"chunkString\");\n      effects.exit('mathFlowFenceMeta');\n      return metaAfter(code);\n    }\n    if (code === 36) {\n      return nok(code);\n    }\n    effects.consume(code);\n    return meta;\n  }\n\n  /**\n   * After meta.\n   *\n   * ```markdown\n   * > | $$\n   *       ^\n   *   | \\frac{1}{2}\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n  function metaAfter(code) {\n    // Guaranteed to be eol/eof.\n    effects.exit('mathFlowFence');\n    if (self.interrupt) {\n      return ok(code);\n    }\n    return effects.attempt(nonLazyContinuation, beforeNonLazyContinuation, after)(code);\n  }\n\n  /**\n   * After eol/eof in math, at a non-lazy closing fence or content.\n   *\n   * ```markdown\n   *   | $$\n   * > | \\frac{1}{2}\n   *     ^\n   * > | $$\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function beforeNonLazyContinuation(code) {\n    return effects.attempt({\n      tokenize: tokenizeClosingFence,\n      partial: true\n    }, after, contentStart)(code);\n  }\n\n  /**\n   * Before math content, definitely not before a closing fence.\n   *\n   * ```markdown\n   *   | $$\n   * > | \\frac{1}{2}\n   *     ^\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n  function contentStart(code) {\n    return (initialSize ? factorySpace(effects, beforeContentChunk, \"linePrefix\", initialSize + 1) : beforeContentChunk)(code);\n  }\n\n  /**\n   * Before math content, after optional prefix.\n   *\n   * ```markdown\n   *   | $$\n   * > | \\frac{1}{2}\n   *     ^\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n  function beforeContentChunk(code) {\n    if (code === null) {\n      return after(code);\n    }\n    if (markdownLineEnding(code)) {\n      return effects.attempt(nonLazyContinuation, beforeNonLazyContinuation, after)(code);\n    }\n    effects.enter('mathFlowValue');\n    return contentChunk(code);\n  }\n\n  /**\n   * In math content.\n   *\n   * ```markdown\n   *   | $$\n   * > | \\frac{1}{2}\n   *      ^\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n  function contentChunk(code) {\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit('mathFlowValue');\n      return beforeContentChunk(code);\n    }\n    effects.consume(code);\n    return contentChunk;\n  }\n\n  /**\n   * After math (ha!).\n   *\n   * ```markdown\n   *   | $$\n   *   | \\frac{1}{2}\n   * > | $$\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function after(code) {\n    effects.exit('mathFlow');\n    return ok(code);\n  }\n\n  /** @type {Tokenizer} */\n  function tokenizeClosingFence(effects, ok, nok) {\n    let size = 0;\n    /**\n     * Before closing fence, at optional whitespace.\n     *\n     * ```markdown\n     *   | $$\n     *   | \\frac{1}{2}\n     * > | $$\n     *     ^\n     * ```\n     */\n    return factorySpace(effects, beforeSequenceClose, \"linePrefix\", self.parser.constructs.disable.null.includes('codeIndented') ? undefined : 4);\n\n    /**\n     * In closing fence, after optional whitespace, at sequence.\n     *\n     * ```markdown\n     *   | $$\n     *   | \\frac{1}{2}\n     * > | $$\n     *     ^\n     * ```\n     *\n     * @type {State}\n     */\n    function beforeSequenceClose(code) {\n      effects.enter('mathFlowFence');\n      effects.enter('mathFlowFenceSequence');\n      return sequenceClose(code);\n    }\n\n    /**\n     * In closing fence sequence.\n     *\n     * ```markdown\n     *   | $$\n     *   | \\frac{1}{2}\n     * > | $$\n     *      ^\n     * ```\n     *\n     * @type {State}\n     */\n    function sequenceClose(code) {\n      if (code === 36) {\n        size++;\n        effects.consume(code);\n        return sequenceClose;\n      }\n      if (size < sizeOpen) {\n        return nok(code);\n      }\n      effects.exit('mathFlowFenceSequence');\n      return factorySpace(effects, afterSequenceClose, \"whitespace\")(code);\n    }\n\n    /**\n     * After closing fence sequence, after optional whitespace.\n     *\n     * ```markdown\n     *   | $$\n     *   | \\frac{1}{2}\n     * > | $$\n     *       ^\n     * ```\n     *\n     * @type {State}\n     */\n    function afterSequenceClose(code) {\n      if (code === null || markdownLineEnding(code)) {\n        effects.exit('mathFlowFence');\n        return ok(code);\n      }\n      return nok(code);\n    }\n  }\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeNonLazyContinuation(effects, ok, nok) {\n  const self = this;\n  return start;\n\n  /** @type {State} */\n  function start(code) {\n    if (code === null) {\n      return ok(code);\n    }\n    effects.enter(\"lineEnding\");\n    effects.consume(code);\n    effects.exit(\"lineEnding\");\n    return lineStart;\n  }\n\n  /** @type {State} */\n  function lineStart(code) {\n    return self.parser.lazy[self.now().line] ? nok(code) : ok(code);\n  }\n}","/**\n * @import {Options} from 'micromark-extension-math'\n * @import {Construct, Previous, Resolver, State, Token, TokenizeContext, Tokenizer} from 'micromark-util-types'\n */\n\n// To do: next major: clean spaces in HTML compiler.\n// This has to be coordinated together with `mdast-util-math`.\n\nimport { markdownLineEnding } from 'micromark-util-character';\n/**\n * @param {Options | null | undefined} [options={}]\n *   Configuration (default: `{}`).\n * @returns {Construct}\n *   Construct.\n */\nexport function mathText(options) {\n  const options_ = options || {};\n  let single = options_.singleDollarTextMath;\n  if (single === null || single === undefined) {\n    single = true;\n  }\n  return {\n    tokenize: tokenizeMathText,\n    resolve: resolveMathText,\n    previous,\n    name: 'mathText'\n  };\n\n  /**\n   * @this {TokenizeContext}\n   * @type {Tokenizer}\n   */\n  function tokenizeMathText(effects, ok, nok) {\n    const self = this;\n    let sizeOpen = 0;\n    /** @type {number} */\n    let size;\n    /** @type {Token} */\n    let token;\n    return start;\n\n    /**\n     * Start of math (text).\n     *\n     * ```markdown\n     * > | $a$\n     *     ^\n     * > | \\$a$\n     *      ^\n     * ```\n     *\n     * @type {State}\n     */\n    function start(code) {\n      effects.enter('mathText');\n      effects.enter('mathTextSequence');\n      return sequenceOpen(code);\n    }\n\n    /**\n     * In opening sequence.\n     *\n     * ```markdown\n     * > | $a$\n     *     ^\n     * ```\n     *\n     * @type {State}\n     */\n\n    function sequenceOpen(code) {\n      if (code === 36) {\n        effects.consume(code);\n        sizeOpen++;\n        return sequenceOpen;\n      }\n\n      // Not enough markers in the sequence.\n      if (sizeOpen < 2 && !single) {\n        return nok(code);\n      }\n      effects.exit('mathTextSequence');\n      return between(code);\n    }\n\n    /**\n     * Between something and something else.\n     *\n     * ```markdown\n     * > | $a$\n     *      ^^\n     * ```\n     *\n     * @type {State}\n     */\n    function between(code) {\n      if (code === null) {\n        return nok(code);\n      }\n      if (code === 36) {\n        token = effects.enter('mathTextSequence');\n        size = 0;\n        return sequenceClose(code);\n      }\n\n      // Tabs don’t work, and virtual spaces don’t make sense.\n      if (code === 32) {\n        effects.enter('space');\n        effects.consume(code);\n        effects.exit('space');\n        return between;\n      }\n      if (markdownLineEnding(code)) {\n        effects.enter(\"lineEnding\");\n        effects.consume(code);\n        effects.exit(\"lineEnding\");\n        return between;\n      }\n\n      // Data.\n      effects.enter('mathTextData');\n      return data(code);\n    }\n\n    /**\n     * In data.\n     *\n     * ```markdown\n     * > | $a$\n     *      ^\n     * ```\n     *\n     * @type {State}\n     */\n    function data(code) {\n      if (code === null || code === 32 || code === 36 || markdownLineEnding(code)) {\n        effects.exit('mathTextData');\n        return between(code);\n      }\n      effects.consume(code);\n      return data;\n    }\n\n    /**\n     * In closing sequence.\n     *\n     * ```markdown\n     * > | `a`\n     *       ^\n     * ```\n     *\n     * @type {State}\n     */\n\n    function sequenceClose(code) {\n      // More.\n      if (code === 36) {\n        effects.consume(code);\n        size++;\n        return sequenceClose;\n      }\n\n      // Done!\n      if (size === sizeOpen) {\n        effects.exit('mathTextSequence');\n        effects.exit('mathText');\n        return ok(code);\n      }\n\n      // More or less accents: mark as data.\n      token.type = 'mathTextData';\n      return data(code);\n    }\n  }\n}\n\n/** @type {Resolver} */\nfunction resolveMathText(events) {\n  let tailExitIndex = events.length - 4;\n  let headEnterIndex = 3;\n  /** @type {number} */\n  let index;\n  /** @type {number | undefined} */\n  let enter;\n\n  // If we start and end with an EOL or a space.\n  if ((events[headEnterIndex][1].type === \"lineEnding\" || events[headEnterIndex][1].type === 'space') && (events[tailExitIndex][1].type === \"lineEnding\" || events[tailExitIndex][1].type === 'space')) {\n    index = headEnterIndex;\n\n    // And we have data.\n    while (++index < tailExitIndex) {\n      if (events[index][1].type === 'mathTextData') {\n        // Then we have padding.\n        events[tailExitIndex][1].type = 'mathTextPadding';\n        events[headEnterIndex][1].type = 'mathTextPadding';\n        headEnterIndex += 2;\n        tailExitIndex -= 2;\n        break;\n      }\n    }\n  }\n\n  // Merge adjacent spaces and data.\n  index = headEnterIndex - 1;\n  tailExitIndex++;\n  while (++index <= tailExitIndex) {\n    if (enter === undefined) {\n      if (index !== tailExitIndex && events[index][1].type !== \"lineEnding\") {\n        enter = index;\n      }\n    } else if (index === tailExitIndex || events[index][1].type === \"lineEnding\") {\n      events[enter][1].type = 'mathTextData';\n      if (index !== enter + 2) {\n        events[enter][1].end = events[index - 1][1].end;\n        events.splice(enter + 2, index - enter - 2);\n        tailExitIndex -= index - enter - 2;\n        index = enter + 2;\n      }\n      enter = undefined;\n    }\n  }\n  return events;\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Previous}\n */\nfunction previous(code) {\n  // If there is a previous code, there will always be a tail.\n  return code !== 36 || this.events[this.events.length - 1][1].type === \"characterEscape\";\n}","/// <reference types=\"mdast-util-math\" />\n/// <reference types=\"remark-parse\" />\n/// <reference types=\"remark-stringify\" />\n\n/**\n * @typedef {import('mdast').Root} Root\n * @typedef {import('mdast-util-math').ToOptions} Options\n * @typedef {import('unified').Processor<Root>} Processor\n */\n\nimport {mathFromMarkdown, mathToMarkdown} from 'mdast-util-math'\nimport {math} from 'micromark-extension-math'\n\n/** @type {Readonly<Options>} */\nconst emptyOptions = {}\n\n/**\n * Add support for math.\n *\n * @param {Readonly<Options> | null | undefined} [options]\n *   Configuration (optional).\n * @returns {undefined}\n *   Nothing.\n */\nexport default function remarkMath(options) {\n  // @ts-expect-error: TS is wrong about `this`.\n  // eslint-disable-next-line unicorn/no-this-assignment\n  const self = /** @type {Processor} */ (this)\n  const settings = options || emptyOptions\n  const data = self.data()\n\n  const micromarkExtensions =\n    data.micromarkExtensions || (data.micromarkExtensions = [])\n  const fromMarkdownExtensions =\n    data.fromMarkdownExtensions || (data.fromMarkdownExtensions = [])\n  const toMarkdownExtensions =\n    data.toMarkdownExtensions || (data.toMarkdownExtensions = [])\n\n  micromarkExtensions.push(math(settings))\n  fromMarkdownExtensions.push(mathFromMarkdown())\n  toMarkdownExtensions.push(mathToMarkdown(settings))\n}\n","/**\n * @import {Options} from 'micromark-extension-math'\n * @import {Extension} from 'micromark-util-types'\n */\n\nimport { mathFlow } from './math-flow.js';\nimport { mathText } from './math-text.js';\n\n/**\n * Create an extension for `micromark` to enable math syntax.\n *\n * @param {Options | null | undefined} [options={}]\n *   Configuration (default: `{}`).\n * @returns {Extension}\n *   Extension for `micromark` that can be passed in `extensions`, to\n *   enable math syntax.\n */\nexport function math(options) {\n  return {\n    flow: {\n      [36]: mathFlow\n    },\n    text: {\n      [36]: mathText(options)\n    }\n  };\n}"],"names":["ok","unreachable","factorySpace","effects","type","max","limit","Number","POSITIVE_INFINITY","size","code","markdownSpace","enter","prefix","consume","exit","asciiAlpha","regexCheck","asciiAlphanumeric","asciiAtext","asciiControl","asciiDigit","asciiHexDigit","asciiPunctuation","markdownLineEnding","markdownLineEndingOrSpace","unicodePunctuation","unicodeWhitespace","regex","test","String","fromCharCode","mathToMarkdown","options","single","singleDollarTextMath","undefined","inlineMath","peek","unsafe","character","inConstruct","after","atBreak","handlers","math","node","_","state","info","raw","value","tracker","createTracker","sequence","repeat","Math","substring","source","index","indexOf","expected","count","TypeError","length","longestStreak","move","meta","subexit","safe","_objectSpread","before","encode","current","RegExp","pattern","expression","compilePattern","match","exec","position","codePointAt","slice","mathFlow","tokenize","nok","self","this","tail","events","initialSize","sliceSerialize","sizeOpen","sequenceOpen","metaBefore","metaAfter","contentType","interrupt","attempt","nonLazyContinuation","beforeNonLazyContinuation","tokenizeClosingFence","partial","contentStart","beforeContentChunk","contentChunk","sequenceClose","parser","constructs","disable","null","includes","afterSequenceClose","concrete","name","lineStart","lazy","now","line","mathText","token","between","data","resolve","resolveMathText","previous","tailExitIndex","headEnterIndex","end","splice","emptyOptions","remarkMath","settings","micromarkExtensions","fromMarkdownExtensions","toMarkdownExtensions","push","flow","text","hName","hChildren","tagName","properties","className","children","mathFlowFenceMeta","buffer","hProperties","resume","replace","stack","assert","mathFlowInside","mathFlowFence","mathFlowValue","exitMathData","mathTextData","config","call","mathFromMarkdown"],"sourceRoot":""}